/**
 * Elastic Email REST API
 * This API is based on the REST API architecture, allowing the user to easily manage their data with this resource-based approach.    Every API call is established on which specific request type (GET, POST, PUT, DELETE) will be used.    To start using this API, you will need your Access Token (available <a target=\"_blank\" href=\"https://elasticemail.com/account#/settings/new/manage-api\">here</a>). Remember to keep it safe. Required access levels are listed in the given request’s description.    This is the documentation for REST API. If you’d like to read our legacy documentation regarding Web API v2 click <a target=\"_blank\" href=\"https://api.elasticemail.com/public/help\">here</a>.    Downloadable library clients can be found in our Github repository <a target=\"_blank\" href=\"https://github.com/ElasticEmail?tab=repositories&q=%22rest+api%22+in%3Areadme\">here</a>
 *
 * The version of the OpenAPI document: 4.0.0
 * Contact: support@elasticemail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent, HttpParameterCodec }       from '@angular/common/http';
import { CustomHttpParameterCodec }                          from '../encoder';
import { Observable }                                        from 'rxjs';

import { ApiKey } from '../model/models';
import { ApiKeyPayload } from '../model/models';
import { NewApiKey } from '../model/models';
import { NewSmtpCredentials } from '../model/models';
import { SmtpCredentials } from '../model/models';
import { SmtpCredentialsPayload } from '../model/models';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';
import {
    SecurityServiceInterface
} from './security.serviceInterface';



@Injectable({
  providedIn: 'root'
})
export class SecurityService implements SecurityServiceInterface {

    protected basePath = 'https://api.elasticemail.com/v4';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();
    public encoder: HttpParameterCodec;

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (configuration) {
            this.configuration = configuration;
        }
        if (typeof this.configuration.basePath !== 'string') {
            if (typeof basePath !== 'string') {
                basePath = this.basePath;
            }
            this.configuration.basePath = basePath;
        }
        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();
    }


    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {
        if (typeof value === "object" && value instanceof Date === false) {
            httpParams = this.addToHttpParamsRecursive(httpParams, value);
        } else {
            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);
        }
        return httpParams;
    }

    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {
        if (value == null) {
            return httpParams;
        }

        if (typeof value === "object") {
            if (Array.isArray(value)) {
                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));
            } else if (value instanceof Date) {
                if (key != null) {
                    httpParams = httpParams.append(key,
                        (value as Date).toISOString().substr(0, 10));
                } else {
                   throw Error("key may not be null if value is Date");
                }
            } else {
                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(
                    httpParams, value[k], key != null ? `${key}.${k}` : k));
            }
        } else if (key != null) {
            httpParams = httpParams.append(key, value);
        } else {
            throw Error("key may not be null if value is not object or array");
        }
        return httpParams;
    }

    /**
     * Delete ApiKey
     * Delete your existing ApiKey. Required Access Level: Security
     * @param name Name of the ApiKey
     * @param subaccount Email of the subaccount of which ApiKey should be deleted
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public securityApikeysByNameDelete(name: string, subaccount?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<any>;
    public securityApikeysByNameDelete(name: string, subaccount?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpResponse<any>>;
    public securityApikeysByNameDelete(name: string, subaccount?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpEvent<any>>;
    public securityApikeysByNameDelete(name: string, subaccount?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: undefined}): Observable<any> {
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling securityApikeysByNameDelete.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (subaccount !== undefined && subaccount !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>subaccount, 'subaccount');
        }

        let headers = this.defaultHeaders;

        let credential: string | undefined;
        // authentication (apikey) required
        credential = this.configuration.lookupCredential('apikey');
        if (credential) {
            headers = headers.set('X-ElasticEmail-ApiKey', credential);
        }

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        let responseType: 'text' | 'json' = 'json';
        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }

        return this.httpClient.delete<any>(`${this.configuration.basePath}/security/apikeys/${encodeURIComponent(String(name))}`,
            {
                params: queryParameters,
                responseType: <any>responseType,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Load ApiKey
     * Load your existing ApiKey info. Required Access Level: Security
     * @param name Name of the ApiKey
     * @param subaccount Email of the subaccount of which ApiKey should be loaded
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public securityApikeysByNameGet(name: string, subaccount?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<ApiKey>;
    public securityApikeysByNameGet(name: string, subaccount?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpResponse<ApiKey>>;
    public securityApikeysByNameGet(name: string, subaccount?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpEvent<ApiKey>>;
    public securityApikeysByNameGet(name: string, subaccount?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json'}): Observable<any> {
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling securityApikeysByNameGet.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (subaccount !== undefined && subaccount !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>subaccount, 'subaccount');
        }

        let headers = this.defaultHeaders;

        let credential: string | undefined;
        // authentication (apikey) required
        credential = this.configuration.lookupCredential('apikey');
        if (credential) {
            headers = headers.set('X-ElasticEmail-ApiKey', credential);
        }

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        let responseType: 'text' | 'json' = 'json';
        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }

        return this.httpClient.get<ApiKey>(`${this.configuration.basePath}/security/apikeys/${encodeURIComponent(String(name))}`,
            {
                params: queryParameters,
                responseType: <any>responseType,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Update ApiKey
     * Update your existing ApiKey. Required Access Level: Security
     * @param name Name of the ApiKey
     * @param apiKeyPayload 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public securityApikeysByNamePut(name: string, apiKeyPayload: ApiKeyPayload, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<ApiKey>;
    public securityApikeysByNamePut(name: string, apiKeyPayload: ApiKeyPayload, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpResponse<ApiKey>>;
    public securityApikeysByNamePut(name: string, apiKeyPayload: ApiKeyPayload, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpEvent<ApiKey>>;
    public securityApikeysByNamePut(name: string, apiKeyPayload: ApiKeyPayload, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json'}): Observable<any> {
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling securityApikeysByNamePut.');
        }
        if (apiKeyPayload === null || apiKeyPayload === undefined) {
            throw new Error('Required parameter apiKeyPayload was null or undefined when calling securityApikeysByNamePut.');
        }

        let headers = this.defaultHeaders;

        let credential: string | undefined;
        // authentication (apikey) required
        credential = this.configuration.lookupCredential('apikey');
        if (credential) {
            headers = headers.set('X-ElasticEmail-ApiKey', credential);
        }

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        let responseType: 'text' | 'json' = 'json';
        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }

        return this.httpClient.put<ApiKey>(`${this.configuration.basePath}/security/apikeys/${encodeURIComponent(String(name))}`,
            apiKeyPayload,
            {
                responseType: <any>responseType,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * List ApiKeys
     * List all your existing ApiKeys. Required Access Level: Security
     * @param subaccount Email of the subaccount of which ApiKeys should be loaded
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public securityApikeysGet(subaccount?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<Array<ApiKey>>;
    public securityApikeysGet(subaccount?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpResponse<Array<ApiKey>>>;
    public securityApikeysGet(subaccount?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpEvent<Array<ApiKey>>>;
    public securityApikeysGet(subaccount?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json'}): Observable<any> {

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (subaccount !== undefined && subaccount !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>subaccount, 'subaccount');
        }

        let headers = this.defaultHeaders;

        let credential: string | undefined;
        // authentication (apikey) required
        credential = this.configuration.lookupCredential('apikey');
        if (credential) {
            headers = headers.set('X-ElasticEmail-ApiKey', credential);
        }

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        let responseType: 'text' | 'json' = 'json';
        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }

        return this.httpClient.get<Array<ApiKey>>(`${this.configuration.basePath}/security/apikeys`,
            {
                params: queryParameters,
                responseType: <any>responseType,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Add ApiKey
     * Add a new ApiKey. Required Access Level: Security
     * @param apiKeyPayload 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public securityApikeysPost(apiKeyPayload: ApiKeyPayload, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<NewApiKey>;
    public securityApikeysPost(apiKeyPayload: ApiKeyPayload, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpResponse<NewApiKey>>;
    public securityApikeysPost(apiKeyPayload: ApiKeyPayload, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpEvent<NewApiKey>>;
    public securityApikeysPost(apiKeyPayload: ApiKeyPayload, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json'}): Observable<any> {
        if (apiKeyPayload === null || apiKeyPayload === undefined) {
            throw new Error('Required parameter apiKeyPayload was null or undefined when calling securityApikeysPost.');
        }

        let headers = this.defaultHeaders;

        let credential: string | undefined;
        // authentication (apikey) required
        credential = this.configuration.lookupCredential('apikey');
        if (credential) {
            headers = headers.set('X-ElasticEmail-ApiKey', credential);
        }

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        let responseType: 'text' | 'json' = 'json';
        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }

        return this.httpClient.post<NewApiKey>(`${this.configuration.basePath}/security/apikeys`,
            apiKeyPayload,
            {
                responseType: <any>responseType,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete SMTP Credential
     * Delete your existing SMTP Credentials. Required Access Level: Security
     * @param name Name of the SMTP Credential
     * @param subaccount Email of the subaccount of which credential should be deleted
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public securitySmtpByNameDelete(name: string, subaccount?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<any>;
    public securitySmtpByNameDelete(name: string, subaccount?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpResponse<any>>;
    public securitySmtpByNameDelete(name: string, subaccount?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpEvent<any>>;
    public securitySmtpByNameDelete(name: string, subaccount?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: undefined}): Observable<any> {
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling securitySmtpByNameDelete.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (subaccount !== undefined && subaccount !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>subaccount, 'subaccount');
        }

        let headers = this.defaultHeaders;

        let credential: string | undefined;
        // authentication (apikey) required
        credential = this.configuration.lookupCredential('apikey');
        if (credential) {
            headers = headers.set('X-ElasticEmail-ApiKey', credential);
        }

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        let responseType: 'text' | 'json' = 'json';
        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }

        return this.httpClient.delete<any>(`${this.configuration.basePath}/security/smtp/${encodeURIComponent(String(name))}`,
            {
                params: queryParameters,
                responseType: <any>responseType,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Load SMTP Credential
     * Load your existing SMTP Credential info. Required Access Level: Security
     * @param name Name of the SMTP Credential
     * @param subaccount Email of the subaccount of which credential should be loaded
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public securitySmtpByNameGet(name: string, subaccount?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<SmtpCredentials>;
    public securitySmtpByNameGet(name: string, subaccount?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpResponse<SmtpCredentials>>;
    public securitySmtpByNameGet(name: string, subaccount?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpEvent<SmtpCredentials>>;
    public securitySmtpByNameGet(name: string, subaccount?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json'}): Observable<any> {
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling securitySmtpByNameGet.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (subaccount !== undefined && subaccount !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>subaccount, 'subaccount');
        }

        let headers = this.defaultHeaders;

        let credential: string | undefined;
        // authentication (apikey) required
        credential = this.configuration.lookupCredential('apikey');
        if (credential) {
            headers = headers.set('X-ElasticEmail-ApiKey', credential);
        }

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        let responseType: 'text' | 'json' = 'json';
        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }

        return this.httpClient.get<SmtpCredentials>(`${this.configuration.basePath}/security/smtp/${encodeURIComponent(String(name))}`,
            {
                params: queryParameters,
                responseType: <any>responseType,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Update SMTP Credential
     * Update your existing SMTP Credentials. Required Access Level: Security
     * @param name Name of the SMTP Credential
     * @param smtpCredentialsPayload 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public securitySmtpByNamePut(name: string, smtpCredentialsPayload: SmtpCredentialsPayload, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<SmtpCredentials>;
    public securitySmtpByNamePut(name: string, smtpCredentialsPayload: SmtpCredentialsPayload, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpResponse<SmtpCredentials>>;
    public securitySmtpByNamePut(name: string, smtpCredentialsPayload: SmtpCredentialsPayload, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpEvent<SmtpCredentials>>;
    public securitySmtpByNamePut(name: string, smtpCredentialsPayload: SmtpCredentialsPayload, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json'}): Observable<any> {
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling securitySmtpByNamePut.');
        }
        if (smtpCredentialsPayload === null || smtpCredentialsPayload === undefined) {
            throw new Error('Required parameter smtpCredentialsPayload was null or undefined when calling securitySmtpByNamePut.');
        }

        let headers = this.defaultHeaders;

        let credential: string | undefined;
        // authentication (apikey) required
        credential = this.configuration.lookupCredential('apikey');
        if (credential) {
            headers = headers.set('X-ElasticEmail-ApiKey', credential);
        }

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        let responseType: 'text' | 'json' = 'json';
        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }

        return this.httpClient.put<SmtpCredentials>(`${this.configuration.basePath}/security/smtp/${encodeURIComponent(String(name))}`,
            smtpCredentialsPayload,
            {
                responseType: <any>responseType,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * List SMTP Credentials
     * List all your existing SMTP Credentials. Required Access Level: Security
     * @param subaccount Email of the subaccount of which credentials should be listed
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public securitySmtpGet(subaccount?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<Array<SmtpCredentials>>;
    public securitySmtpGet(subaccount?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpResponse<Array<SmtpCredentials>>>;
    public securitySmtpGet(subaccount?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpEvent<Array<SmtpCredentials>>>;
    public securitySmtpGet(subaccount?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json'}): Observable<any> {

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (subaccount !== undefined && subaccount !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>subaccount, 'subaccount');
        }

        let headers = this.defaultHeaders;

        let credential: string | undefined;
        // authentication (apikey) required
        credential = this.configuration.lookupCredential('apikey');
        if (credential) {
            headers = headers.set('X-ElasticEmail-ApiKey', credential);
        }

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        let responseType: 'text' | 'json' = 'json';
        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }

        return this.httpClient.get<Array<SmtpCredentials>>(`${this.configuration.basePath}/security/smtp`,
            {
                params: queryParameters,
                responseType: <any>responseType,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Add SMTP Credential
     * Add new SMTP Credential. Required Access Level: Security
     * @param smtpCredentialsPayload 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public securitySmtpPost(smtpCredentialsPayload: SmtpCredentialsPayload, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<NewSmtpCredentials>;
    public securitySmtpPost(smtpCredentialsPayload: SmtpCredentialsPayload, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpResponse<NewSmtpCredentials>>;
    public securitySmtpPost(smtpCredentialsPayload: SmtpCredentialsPayload, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpEvent<NewSmtpCredentials>>;
    public securitySmtpPost(smtpCredentialsPayload: SmtpCredentialsPayload, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json'}): Observable<any> {
        if (smtpCredentialsPayload === null || smtpCredentialsPayload === undefined) {
            throw new Error('Required parameter smtpCredentialsPayload was null or undefined when calling securitySmtpPost.');
        }

        let headers = this.defaultHeaders;

        let credential: string | undefined;
        // authentication (apikey) required
        credential = this.configuration.lookupCredential('apikey');
        if (credential) {
            headers = headers.set('X-ElasticEmail-ApiKey', credential);
        }

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        let responseType: 'text' | 'json' = 'json';
        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }

        return this.httpClient.post<NewSmtpCredentials>(`${this.configuration.basePath}/security/smtp`,
            smtpCredentialsPayload,
            {
                responseType: <any>responseType,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
